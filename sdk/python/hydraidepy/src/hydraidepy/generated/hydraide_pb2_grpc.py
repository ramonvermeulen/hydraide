# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

import hydraide_pb2 as hydraide__pb2

GRPC_GENERATED_VERSION = '1.74.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in hydraide_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class HydraideServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Heartbeat = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Heartbeat',
                request_serializer=hydraide__pb2.HeartbeatRequest.SerializeToString,
                response_deserializer=hydraide__pb2.HeartbeatResponse.FromString,
                _registered_method=True)
        self.Lock = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Lock',
                request_serializer=hydraide__pb2.LockRequest.SerializeToString,
                response_deserializer=hydraide__pb2.LockResponse.FromString,
                _registered_method=True)
        self.Unlock = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Unlock',
                request_serializer=hydraide__pb2.UnlockRequest.SerializeToString,
                response_deserializer=hydraide__pb2.UnlockResponse.FromString,
                _registered_method=True)
        self.RegisterSwamp = channel.unary_unary(
                '/hydraidepbgo.HydraideService/RegisterSwamp',
                request_serializer=hydraide__pb2.RegisterSwampRequest.SerializeToString,
                response_deserializer=hydraide__pb2.RegisterSwampResponse.FromString,
                _registered_method=True)
        self.DeRegisterSwamp = channel.unary_unary(
                '/hydraidepbgo.HydraideService/DeRegisterSwamp',
                request_serializer=hydraide__pb2.DeRegisterSwampRequest.SerializeToString,
                response_deserializer=hydraide__pb2.DeRegisterSwampResponse.FromString,
                _registered_method=True)
        self.Set = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Set',
                request_serializer=hydraide__pb2.SetRequest.SerializeToString,
                response_deserializer=hydraide__pb2.SetResponse.FromString,
                _registered_method=True)
        self.Get = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Get',
                request_serializer=hydraide__pb2.GetRequest.SerializeToString,
                response_deserializer=hydraide__pb2.GetResponse.FromString,
                _registered_method=True)
        self.GetAll = channel.unary_unary(
                '/hydraidepbgo.HydraideService/GetAll',
                request_serializer=hydraide__pb2.GetAllRequest.SerializeToString,
                response_deserializer=hydraide__pb2.GetAllResponse.FromString,
                _registered_method=True)
        self.GetByIndex = channel.unary_unary(
                '/hydraidepbgo.HydraideService/GetByIndex',
                request_serializer=hydraide__pb2.GetByIndexRequest.SerializeToString,
                response_deserializer=hydraide__pb2.GetByIndexResponse.FromString,
                _registered_method=True)
        self.ShiftExpiredTreasures = channel.unary_unary(
                '/hydraidepbgo.HydraideService/ShiftExpiredTreasures',
                request_serializer=hydraide__pb2.ShiftExpiredTreasuresRequest.SerializeToString,
                response_deserializer=hydraide__pb2.ShiftExpiredTreasuresResponse.FromString,
                _registered_method=True)
        self.Destroy = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Destroy',
                request_serializer=hydraide__pb2.DestroyRequest.SerializeToString,
                response_deserializer=hydraide__pb2.DestroyResponse.FromString,
                _registered_method=True)
        self.Delete = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Delete',
                request_serializer=hydraide__pb2.DeleteRequest.SerializeToString,
                response_deserializer=hydraide__pb2.DeleteResponse.FromString,
                _registered_method=True)
        self.Count = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Count',
                request_serializer=hydraide__pb2.CountRequest.SerializeToString,
                response_deserializer=hydraide__pb2.CountResponse.FromString,
                _registered_method=True)
        self.IsSwampExist = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IsSwampExist',
                request_serializer=hydraide__pb2.IsSwampExistRequest.SerializeToString,
                response_deserializer=hydraide__pb2.IsSwampExistResponse.FromString,
                _registered_method=True)
        self.IsKeyExist = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IsKeyExist',
                request_serializer=hydraide__pb2.IsKeyExistRequest.SerializeToString,
                response_deserializer=hydraide__pb2.IsKeyExistResponse.FromString,
                _registered_method=True)
        self.SubscribeToEvents = channel.unary_stream(
                '/hydraidepbgo.HydraideService/SubscribeToEvents',
                request_serializer=hydraide__pb2.SubscribeToEventsRequest.SerializeToString,
                response_deserializer=hydraide__pb2.SubscribeToEventsResponse.FromString,
                _registered_method=True)
        self.SubscribeToInfo = channel.unary_stream(
                '/hydraidepbgo.HydraideService/SubscribeToInfo',
                request_serializer=hydraide__pb2.SubscribeToInfoRequest.SerializeToString,
                response_deserializer=hydraide__pb2.SubscribeToInfoResponse.FromString,
                _registered_method=True)
        self.Uint32SlicePush = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Uint32SlicePush',
                request_serializer=hydraide__pb2.AddToUint32SlicePushRequest.SerializeToString,
                response_deserializer=hydraide__pb2.AddToUint32SlicePushResponse.FromString,
                _registered_method=True)
        self.Uint32SliceDelete = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Uint32SliceDelete',
                request_serializer=hydraide__pb2.Uint32SliceDeleteRequest.SerializeToString,
                response_deserializer=hydraide__pb2.Uint32SliceDeleteResponse.FromString,
                _registered_method=True)
        self.Uint32SliceSize = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Uint32SliceSize',
                request_serializer=hydraide__pb2.Uint32SliceSizeRequest.SerializeToString,
                response_deserializer=hydraide__pb2.Uint32SliceSizeResponse.FromString,
                _registered_method=True)
        self.Uint32SliceIsValueExist = channel.unary_unary(
                '/hydraidepbgo.HydraideService/Uint32SliceIsValueExist',
                request_serializer=hydraide__pb2.Uint32SliceIsValueExistRequest.SerializeToString,
                response_deserializer=hydraide__pb2.Uint32SliceIsValueExistResponse.FromString,
                _registered_method=True)
        self.IncrementInt8 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementInt8',
                request_serializer=hydraide__pb2.IncrementInt8Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementInt8Response.FromString,
                _registered_method=True)
        self.IncrementInt16 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementInt16',
                request_serializer=hydraide__pb2.IncrementInt16Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementInt16Response.FromString,
                _registered_method=True)
        self.IncrementInt32 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementInt32',
                request_serializer=hydraide__pb2.IncrementInt32Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementInt32Response.FromString,
                _registered_method=True)
        self.IncrementInt64 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementInt64',
                request_serializer=hydraide__pb2.IncrementInt64Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementInt64Response.FromString,
                _registered_method=True)
        self.IncrementUint8 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementUint8',
                request_serializer=hydraide__pb2.IncrementUint8Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementUint8Response.FromString,
                _registered_method=True)
        self.IncrementUint16 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementUint16',
                request_serializer=hydraide__pb2.IncrementUint16Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementUint16Response.FromString,
                _registered_method=True)
        self.IncrementUint32 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementUint32',
                request_serializer=hydraide__pb2.IncrementUint32Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementUint32Response.FromString,
                _registered_method=True)
        self.IncrementUint64 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementUint64',
                request_serializer=hydraide__pb2.IncrementUint64Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementUint64Response.FromString,
                _registered_method=True)
        self.IncrementFloat32 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementFloat32',
                request_serializer=hydraide__pb2.IncrementFloat32Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementFloat32Response.FromString,
                _registered_method=True)
        self.IncrementFloat64 = channel.unary_unary(
                '/hydraidepbgo.HydraideService/IncrementFloat64',
                request_serializer=hydraide__pb2.IncrementFloat64Request.SerializeToString,
                response_deserializer=hydraide__pb2.IncrementFloat64Response.FromString,
                _registered_method=True)


class HydraideServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def Heartbeat(self, request, context):
        """Heartbeat checks if the HydrAIDE server is alive.
        The client sends a Ping and expects a Pong response.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Lock(self, request, context):
        """Lock allows you to create a mutex-like lock based on a given key.
        It queues all lock requests for the same key and only returns once the lock is granted.
        This mechanism enables swamp- or treasure-level locking to coordinate access between microservices.

        ‚ö†Ô∏è Note: Locking is logical only ‚Äî it does not block the actual data access unless your logic respects the lock.
        You must explicitly use the Lock/Unlock sequence around relevant operations.

        Required: TTL must be set (timeout in milliseconds).
        If the lock cannot be acquired within this TTL, the call returns an error.
        If a lock is granted, a LockID is returned, which must be passed to Unlock.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Unlock(self, request, context):
        """Unlock releases the previously granted lock based on the key and LockID.
        If the LockID is invalid or does not match an existing lock, the call fails.

        It is crucial to always unlock your locks to avoid deadlocks.
        If the TTL expires, the lock is automatically released.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RegisterSwamp(self, request, context):
        """RegisterSwamp registers a new swamp pattern in the HydrAIDE system.
        A swamp pattern defines the namespace (Sanctuary/Realm/Swamp) and behavior of a storage unit.

        You can configure:
        - Whether the swamp lives in memory or on disk
        - How long it should stay alive without access (CloseAfterIdle)
        - How frequently it should flush to disk (WriteInterval)
        - Maximum file size per chunk (MaxFileSize)

        Use this to define behavior per collection before inserting data.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def DeRegisterSwamp(self, request, context):
        """DeRegisterSwamp removes a previously registered swamp pattern.
        This does not delete the swamp data ‚Äî it only removes its active configuration.

        Use this to clean up unused swamp definitions.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Set(self, request, context):
        """Set inserts or updates one or more key-value pairs into one or more swamps.
        You can control the behavior using two flags:
        - CreateIfNotExist: If false, the swamp/key must already exist (update only).
        - Overwrite: If false, the existing value will not be overwritten.

        ‚ö†Ô∏è Each KeyValuePair supports multiple data types:
        - All numeric primitives: int8, int16, int32, int64, uint8, uint16, uint32, uint64
        - Floating point types: float32, float64
        - Booleans, strings, bytes, and even slices (e.g., uint32[])

        üí° HydrAIDE stores the value using its **actual underlying type** without upcasting,
        which means no wasted memory or disk space ‚Äì you only store what you really need.

        You can also set metadata like CreatedAt, UpdatedBy, ExpiredAt, etc.

        ‚úÖ Supports multiple swamps in a single request for batch operations.

        üîî Realtime: Any inserted or updated treasures will trigger an immediate
        event to all active subscribers via the SubscribeToEvents stream.

        This makes HydrAIDE suitable for:
        - Real-time dashboards
        - Cache invalidation listeners
        - Live analytics feeds
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Get(self, request, context):
        """Get retrieves one or more key-value pairs by key from one or more swamps.
        You must specify the swamp name and the list of keys per swamp.

        Each response includes the key, value, and metadata fields (timestamps, creators).
        This is a type-safe, structured read ‚Äì no JSON parsing needed on the client side.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetAll(self, request, context):
        """GetAll retrieves **all** key-value pairs from a given swamp.

        This is useful for debug purposes, cache rebuilding, or initial snapshot creation.
        Not recommended for large datasets unless scoped and filtered client-side.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetByIndex(self, request, context):
        """GetByIndex allows indexed reads based on fields like:
        - ExpirationTime
        - CreationTime
        - Value types (e.g., VALUE_STRING, VALUE_INT32, etc.)

        You can specify the index type, sorting order (ASC/DESC), and a range using From/Limit.
        This makes the HydrAIDE engine powerful for search, feed, and queue-like structures.

        ‚ö†Ô∏è HydrAIDE creates index structures on-demand in memory when this method is called.
        These indexes are **not persisted**, and are **discarded when the swamp is closed** due to inactivity.
        This means indexing is stateless, fast, and leaves no storage overhead.

        You do not need to pre-define indexes. Simply call this method with the right IndexType.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ShiftExpiredTreasures(self, request, context):
        """ShiftExpiredTreasures retrieves and deletes expired treasures from a given swamp.

        This method is ideal for implementing task queues, time-based processing systems,
        or scheduled cleanup mechanisms where only expired items should be processed.

        You can control how many items to retrieve at once using the `HowMany` parameter:
        - If `HowMany` is 0, all expired treasures will be returned (use with caution on large swamps)
        - If `HowMany` > 0, only that many expired entries will be returned in the response

        ‚ö†Ô∏è Important: This method is destructive ‚Äì the returned items will be permanently removed from the swamp.

        üîî Realtime: All subscribers to the swamp will receive an immediate
        notification about the deleted treasures via the SubscribeToEvents stream.

        Use this for building things like:
        - Delayed jobs
        - Expiring caches
        - Scheduled triggers (e.g. publish-after-expiry)
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Destroy(self, request, context):
        """Destroy permanently deletes the entire swamp and all its treasures.

        This removes all data associated with the given swamp, including metadata, indexes, and chunks.

        ‚ö†Ô∏è Warning: This operation is irreversible. All data will be lost.
        Use only when you're absolutely sure the swamp is no longer needed.

        Typical use cases:
        - Cleanup after tests or temporary data
        - User data deletion requests
        - Full environment reset
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Delete(self, request, context):
        """Delete removes one or more treasures (key-value pairs) from the specified swamp.

        This is a precise, non-destructive swamp-level operation.
        You must provide the swamp name and the list of keys to delete.

        ‚úÖ Supports batch deletion across multiple swamps in a single request.
        Each swamp and its deleted keys will be included in the response.

        üîî Realtime: All subscribers to the swamp will receive an immediate
        notification about the deleted treasures via the SubscribeToEvents stream.

        Use this to:
        - Manually remove outdated or invalid entries
        - Implement "soft delete" logic (client-side)
        - Perform targeted cleanup operations
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Count(self, request, context):
        """Count returns the number of treasures in one or more specified swamps.

        You provide a list of swamp names, and for each swamp HydrAIDE returns:
        - Whether the swamp exists
        - How many elements (treasures) are currently stored in it

        ‚úÖ This is useful for:
        - Dashboard metrics and monitoring
        - Queue size estimation
        - Expiry-aware cleanup or batch logic

        üí° The count is calculated instantly from the swamp‚Äôs current state,
        with no need for full traversal or manual iteration.

        Can be used across multiple swamps in a single request.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IsSwampExist(self, request, context):
        """IsSwampExist checks if the specified swamp exists in the given sanctuary.

        This method does not create or modify anything ‚Äì it only verifies existence.
        Use it to validate swamp names before writing, migrating, or deleting.

        Typical use cases:
        - Pre-checks before Set/Delete operations
        - UI/UX logic (e.g. show/hide a swamp)
        - Schema validation before batch processing

        üí° Note: Swamp existence does not guarantee any treasures inside ‚Äì it's purely structural.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IsKeyExist(self, request, context):
        """IsKeyExist checks whether a specific key exists in a given swamp.

        This allows you to verify the presence of a treasure without retrieving its content.

        Use cases include:
        - Validation before conditional logic (e.g. overwrite if exists)
        - Data consistency checks
        - TTL-aware logic (e.g. only update if key is still present)

        üí° Note: The value is not returned ‚Äì only a boolean indicator of existence.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SubscribeToEvents(self, request, context):
        """SubscribeToEvents allows clients to subscribe to **all data changes** within a given swamp.

        When any treasure in the swamp is created, updated, or deleted,
        the subscriber immediately receives an event via the gRPC stream.

        Each event includes:
        - The new Treasure (after Set, Shift, etc.)
        - The previous Treasure (if updated)
        - The deleted Treasure (if removed)
        - The EventType: NEW, UPDATED, DELETED, etc.
        - The timestamp of the change

        üîÅ Events are streamed continuously and in real time, making this ideal for:
        - Realtime dashboards
        - Reactive frontends (e.g. auto-refreshing tables)
        - Notification systems
        - Chat or messaging systems (event-driven communication)
        - Distributed coordination (e.g. data sync across services)
        - Microservice communication via event stream

        üí° You can use this to completely replace traditional polling or cron-based checks.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SubscribeToInfo(self, request, context):
        """SubscribeToInfo allows clients to subscribe to the **size** of a given swamp.

        Whenever the number of treasures changes in the swamp (insert, delete, expire),
        the client receives a realtime update of the current element count.

        This is useful for:
        - Showing live counters or progress bars
        - Monitoring queue sizes
        - Displaying health metrics or swamp saturation

        ‚ö° Events are sent immediately upon any change to the number of elements.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Uint32SlicePush(self, request, context):
        """Uint32SlicePush adds one or more uint32 values to one or more uint32 slices stored in a swamp.

        üí° HydrAIDE automatically ensures that each value is unique within the slice.
        If a number already exists, it will be ignored ‚Äì no duplicates are ever stored.

        You can safely push multiple values at once, even if some already exist.
        The resulting slice will contain only distinct uint32 values.

        üîî Any change to the slice triggers a real-time event to all swamp subscribers.
        The full updated slice is included in the event payload.

        This feature is ideal for building:
        - Reverse indexes (e.g. word ‚Üí [domainHash1, domainHash2])
        - Subscriptions, permissions, ID-based tagging
        - Memory-efficient, append-only ID lists

        ‚ö†Ô∏è Recommended for cases where the slice size is small to moderate,
        as the full slice is returned on each update.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Uint32SliceDelete(self, request, context):
        """Uint32SliceDelete removes one or more uint32 values from one or more slices.

        If a value does not exist, it is silently ignored (no error thrown).
        The key itself (treasure) is preserved ‚Äì only the values inside the slice are modified.

        üîî The deletion also triggers a real-time event to all subscribers.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Uint32SliceSize(self, request, context):
        """Uint32SliceSize returns the number of values stored in the uint32 slice.

        Use this to:
        - Show visual counters
        - Estimate memory usage
        - Monitor collection density
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Uint32SliceIsValueExist(self, request, context):
        """Uint32SliceIsValueExist checks whether a specific value exists inside the slice.

        This is useful when you want to validate membership before taking actions,
        such as displaying UI states or preventing duplicate logic.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementInt8(self, request, context):
        """IncrementInt8 increments (or decrements) the value of the key by the specified amount,
        if a given condition is satisfied.

        üí° The increment can be negative ‚Äì enabling both increment and decrement operations.
        If the condition fails, the value is not modified.

        The response includes:
        - The new (or original) value
        - Whether the increment was applied

        üîî Realtime: Any change triggers an immediate event to all swamp subscribers via SubscribeToEvents.

        Typical use cases:
        - Counter logic (votes, likes, attempts)
        - Conditional stock adjustments
        - Quota or retry limits
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementInt16(self, request, context):
        """IncrementInt8 same logic as IncrementInt8 but for int16 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementInt32(self, request, context):
        """IncrementInt32 same logic as IncrementInt8 but for int32 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementInt64(self, request, context):
        """IncrementInt64 same logic as IncrementInt8 but for int64 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementUint8(self, request, context):
        """IncrementUint8 same logic as IncrementInt8 but for uint8 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementUint16(self, request, context):
        """IncrementUint16 same logic as IncrementInt8 but for uint16 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementUint32(self, request, context):
        """IncrementUint32 same logic as IncrementInt8 but for uint32 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementUint64(self, request, context):
        """IncrementUint64 same logic as IncrementInt8 but for uint64 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementFloat32(self, request, context):
        """IncrementFloat32 same logic as IncrementInt8 but for float32 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def IncrementFloat64(self, request, context):
        """IncrementFloat64 same logic as IncrementInt8 but for float64 values
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_HydraideServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Heartbeat': grpc.unary_unary_rpc_method_handler(
                    servicer.Heartbeat,
                    request_deserializer=hydraide__pb2.HeartbeatRequest.FromString,
                    response_serializer=hydraide__pb2.HeartbeatResponse.SerializeToString,
            ),
            'Lock': grpc.unary_unary_rpc_method_handler(
                    servicer.Lock,
                    request_deserializer=hydraide__pb2.LockRequest.FromString,
                    response_serializer=hydraide__pb2.LockResponse.SerializeToString,
            ),
            'Unlock': grpc.unary_unary_rpc_method_handler(
                    servicer.Unlock,
                    request_deserializer=hydraide__pb2.UnlockRequest.FromString,
                    response_serializer=hydraide__pb2.UnlockResponse.SerializeToString,
            ),
            'RegisterSwamp': grpc.unary_unary_rpc_method_handler(
                    servicer.RegisterSwamp,
                    request_deserializer=hydraide__pb2.RegisterSwampRequest.FromString,
                    response_serializer=hydraide__pb2.RegisterSwampResponse.SerializeToString,
            ),
            'DeRegisterSwamp': grpc.unary_unary_rpc_method_handler(
                    servicer.DeRegisterSwamp,
                    request_deserializer=hydraide__pb2.DeRegisterSwampRequest.FromString,
                    response_serializer=hydraide__pb2.DeRegisterSwampResponse.SerializeToString,
            ),
            'Set': grpc.unary_unary_rpc_method_handler(
                    servicer.Set,
                    request_deserializer=hydraide__pb2.SetRequest.FromString,
                    response_serializer=hydraide__pb2.SetResponse.SerializeToString,
            ),
            'Get': grpc.unary_unary_rpc_method_handler(
                    servicer.Get,
                    request_deserializer=hydraide__pb2.GetRequest.FromString,
                    response_serializer=hydraide__pb2.GetResponse.SerializeToString,
            ),
            'GetAll': grpc.unary_unary_rpc_method_handler(
                    servicer.GetAll,
                    request_deserializer=hydraide__pb2.GetAllRequest.FromString,
                    response_serializer=hydraide__pb2.GetAllResponse.SerializeToString,
            ),
            'GetByIndex': grpc.unary_unary_rpc_method_handler(
                    servicer.GetByIndex,
                    request_deserializer=hydraide__pb2.GetByIndexRequest.FromString,
                    response_serializer=hydraide__pb2.GetByIndexResponse.SerializeToString,
            ),
            'ShiftExpiredTreasures': grpc.unary_unary_rpc_method_handler(
                    servicer.ShiftExpiredTreasures,
                    request_deserializer=hydraide__pb2.ShiftExpiredTreasuresRequest.FromString,
                    response_serializer=hydraide__pb2.ShiftExpiredTreasuresResponse.SerializeToString,
            ),
            'Destroy': grpc.unary_unary_rpc_method_handler(
                    servicer.Destroy,
                    request_deserializer=hydraide__pb2.DestroyRequest.FromString,
                    response_serializer=hydraide__pb2.DestroyResponse.SerializeToString,
            ),
            'Delete': grpc.unary_unary_rpc_method_handler(
                    servicer.Delete,
                    request_deserializer=hydraide__pb2.DeleteRequest.FromString,
                    response_serializer=hydraide__pb2.DeleteResponse.SerializeToString,
            ),
            'Count': grpc.unary_unary_rpc_method_handler(
                    servicer.Count,
                    request_deserializer=hydraide__pb2.CountRequest.FromString,
                    response_serializer=hydraide__pb2.CountResponse.SerializeToString,
            ),
            'IsSwampExist': grpc.unary_unary_rpc_method_handler(
                    servicer.IsSwampExist,
                    request_deserializer=hydraide__pb2.IsSwampExistRequest.FromString,
                    response_serializer=hydraide__pb2.IsSwampExistResponse.SerializeToString,
            ),
            'IsKeyExist': grpc.unary_unary_rpc_method_handler(
                    servicer.IsKeyExist,
                    request_deserializer=hydraide__pb2.IsKeyExistRequest.FromString,
                    response_serializer=hydraide__pb2.IsKeyExistResponse.SerializeToString,
            ),
            'SubscribeToEvents': grpc.unary_stream_rpc_method_handler(
                    servicer.SubscribeToEvents,
                    request_deserializer=hydraide__pb2.SubscribeToEventsRequest.FromString,
                    response_serializer=hydraide__pb2.SubscribeToEventsResponse.SerializeToString,
            ),
            'SubscribeToInfo': grpc.unary_stream_rpc_method_handler(
                    servicer.SubscribeToInfo,
                    request_deserializer=hydraide__pb2.SubscribeToInfoRequest.FromString,
                    response_serializer=hydraide__pb2.SubscribeToInfoResponse.SerializeToString,
            ),
            'Uint32SlicePush': grpc.unary_unary_rpc_method_handler(
                    servicer.Uint32SlicePush,
                    request_deserializer=hydraide__pb2.AddToUint32SlicePushRequest.FromString,
                    response_serializer=hydraide__pb2.AddToUint32SlicePushResponse.SerializeToString,
            ),
            'Uint32SliceDelete': grpc.unary_unary_rpc_method_handler(
                    servicer.Uint32SliceDelete,
                    request_deserializer=hydraide__pb2.Uint32SliceDeleteRequest.FromString,
                    response_serializer=hydraide__pb2.Uint32SliceDeleteResponse.SerializeToString,
            ),
            'Uint32SliceSize': grpc.unary_unary_rpc_method_handler(
                    servicer.Uint32SliceSize,
                    request_deserializer=hydraide__pb2.Uint32SliceSizeRequest.FromString,
                    response_serializer=hydraide__pb2.Uint32SliceSizeResponse.SerializeToString,
            ),
            'Uint32SliceIsValueExist': grpc.unary_unary_rpc_method_handler(
                    servicer.Uint32SliceIsValueExist,
                    request_deserializer=hydraide__pb2.Uint32SliceIsValueExistRequest.FromString,
                    response_serializer=hydraide__pb2.Uint32SliceIsValueExistResponse.SerializeToString,
            ),
            'IncrementInt8': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementInt8,
                    request_deserializer=hydraide__pb2.IncrementInt8Request.FromString,
                    response_serializer=hydraide__pb2.IncrementInt8Response.SerializeToString,
            ),
            'IncrementInt16': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementInt16,
                    request_deserializer=hydraide__pb2.IncrementInt16Request.FromString,
                    response_serializer=hydraide__pb2.IncrementInt16Response.SerializeToString,
            ),
            'IncrementInt32': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementInt32,
                    request_deserializer=hydraide__pb2.IncrementInt32Request.FromString,
                    response_serializer=hydraide__pb2.IncrementInt32Response.SerializeToString,
            ),
            'IncrementInt64': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementInt64,
                    request_deserializer=hydraide__pb2.IncrementInt64Request.FromString,
                    response_serializer=hydraide__pb2.IncrementInt64Response.SerializeToString,
            ),
            'IncrementUint8': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementUint8,
                    request_deserializer=hydraide__pb2.IncrementUint8Request.FromString,
                    response_serializer=hydraide__pb2.IncrementUint8Response.SerializeToString,
            ),
            'IncrementUint16': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementUint16,
                    request_deserializer=hydraide__pb2.IncrementUint16Request.FromString,
                    response_serializer=hydraide__pb2.IncrementUint16Response.SerializeToString,
            ),
            'IncrementUint32': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementUint32,
                    request_deserializer=hydraide__pb2.IncrementUint32Request.FromString,
                    response_serializer=hydraide__pb2.IncrementUint32Response.SerializeToString,
            ),
            'IncrementUint64': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementUint64,
                    request_deserializer=hydraide__pb2.IncrementUint64Request.FromString,
                    response_serializer=hydraide__pb2.IncrementUint64Response.SerializeToString,
            ),
            'IncrementFloat32': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementFloat32,
                    request_deserializer=hydraide__pb2.IncrementFloat32Request.FromString,
                    response_serializer=hydraide__pb2.IncrementFloat32Response.SerializeToString,
            ),
            'IncrementFloat64': grpc.unary_unary_rpc_method_handler(
                    servicer.IncrementFloat64,
                    request_deserializer=hydraide__pb2.IncrementFloat64Request.FromString,
                    response_serializer=hydraide__pb2.IncrementFloat64Response.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'hydraidepbgo.HydraideService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('hydraidepbgo.HydraideService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class HydraideService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def Heartbeat(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Heartbeat',
            hydraide__pb2.HeartbeatRequest.SerializeToString,
            hydraide__pb2.HeartbeatResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Lock(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Lock',
            hydraide__pb2.LockRequest.SerializeToString,
            hydraide__pb2.LockResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Unlock(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Unlock',
            hydraide__pb2.UnlockRequest.SerializeToString,
            hydraide__pb2.UnlockResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def RegisterSwamp(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/RegisterSwamp',
            hydraide__pb2.RegisterSwampRequest.SerializeToString,
            hydraide__pb2.RegisterSwampResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def DeRegisterSwamp(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/DeRegisterSwamp',
            hydraide__pb2.DeRegisterSwampRequest.SerializeToString,
            hydraide__pb2.DeRegisterSwampResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Set(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Set',
            hydraide__pb2.SetRequest.SerializeToString,
            hydraide__pb2.SetResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Get(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Get',
            hydraide__pb2.GetRequest.SerializeToString,
            hydraide__pb2.GetResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetAll(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/GetAll',
            hydraide__pb2.GetAllRequest.SerializeToString,
            hydraide__pb2.GetAllResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetByIndex(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/GetByIndex',
            hydraide__pb2.GetByIndexRequest.SerializeToString,
            hydraide__pb2.GetByIndexResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ShiftExpiredTreasures(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/ShiftExpiredTreasures',
            hydraide__pb2.ShiftExpiredTreasuresRequest.SerializeToString,
            hydraide__pb2.ShiftExpiredTreasuresResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Destroy(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Destroy',
            hydraide__pb2.DestroyRequest.SerializeToString,
            hydraide__pb2.DestroyResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Delete(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Delete',
            hydraide__pb2.DeleteRequest.SerializeToString,
            hydraide__pb2.DeleteResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Count(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Count',
            hydraide__pb2.CountRequest.SerializeToString,
            hydraide__pb2.CountResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IsSwampExist(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IsSwampExist',
            hydraide__pb2.IsSwampExistRequest.SerializeToString,
            hydraide__pb2.IsSwampExistResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IsKeyExist(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IsKeyExist',
            hydraide__pb2.IsKeyExistRequest.SerializeToString,
            hydraide__pb2.IsKeyExistResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SubscribeToEvents(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/hydraidepbgo.HydraideService/SubscribeToEvents',
            hydraide__pb2.SubscribeToEventsRequest.SerializeToString,
            hydraide__pb2.SubscribeToEventsResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SubscribeToInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/hydraidepbgo.HydraideService/SubscribeToInfo',
            hydraide__pb2.SubscribeToInfoRequest.SerializeToString,
            hydraide__pb2.SubscribeToInfoResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Uint32SlicePush(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Uint32SlicePush',
            hydraide__pb2.AddToUint32SlicePushRequest.SerializeToString,
            hydraide__pb2.AddToUint32SlicePushResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Uint32SliceDelete(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Uint32SliceDelete',
            hydraide__pb2.Uint32SliceDeleteRequest.SerializeToString,
            hydraide__pb2.Uint32SliceDeleteResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Uint32SliceSize(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Uint32SliceSize',
            hydraide__pb2.Uint32SliceSizeRequest.SerializeToString,
            hydraide__pb2.Uint32SliceSizeResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Uint32SliceIsValueExist(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/Uint32SliceIsValueExist',
            hydraide__pb2.Uint32SliceIsValueExistRequest.SerializeToString,
            hydraide__pb2.Uint32SliceIsValueExistResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementInt8(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementInt8',
            hydraide__pb2.IncrementInt8Request.SerializeToString,
            hydraide__pb2.IncrementInt8Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementInt16(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementInt16',
            hydraide__pb2.IncrementInt16Request.SerializeToString,
            hydraide__pb2.IncrementInt16Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementInt32(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementInt32',
            hydraide__pb2.IncrementInt32Request.SerializeToString,
            hydraide__pb2.IncrementInt32Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementInt64(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementInt64',
            hydraide__pb2.IncrementInt64Request.SerializeToString,
            hydraide__pb2.IncrementInt64Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementUint8(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementUint8',
            hydraide__pb2.IncrementUint8Request.SerializeToString,
            hydraide__pb2.IncrementUint8Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementUint16(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementUint16',
            hydraide__pb2.IncrementUint16Request.SerializeToString,
            hydraide__pb2.IncrementUint16Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementUint32(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementUint32',
            hydraide__pb2.IncrementUint32Request.SerializeToString,
            hydraide__pb2.IncrementUint32Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementUint64(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementUint64',
            hydraide__pb2.IncrementUint64Request.SerializeToString,
            hydraide__pb2.IncrementUint64Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementFloat32(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementFloat32',
            hydraide__pb2.IncrementFloat32Request.SerializeToString,
            hydraide__pb2.IncrementFloat32Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def IncrementFloat64(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/hydraidepbgo.HydraideService/IncrementFloat64',
            hydraide__pb2.IncrementFloat64Request.SerializeToString,
            hydraide__pb2.IncrementFloat64Response.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
