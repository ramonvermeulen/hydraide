// =============================================================================
// ðŸ§  HydraService â€“ gRPC Interface for Hydra 2.0
// =============================================================================
//
// This file defines the complete public gRPC API for the Hydra data engine.
//
// Hydra is a high-performance, real-time, distributed data engine
// built for ultra-fast, fine-grained control of your storage, memory, and compute needs.
// It powers search, queueing, caching, analytics, and more â€” all in one.
//
// ðŸ”’ This interface is used to communicate with a closed-source Hydra server.
// You are free to build your own clients (SDKs) using this specification,
// but the server binary is licensed separately under commercial terms.
//
// ðŸ“œ License: Apache 2.0 for this interface definition only
// ðŸ’¡ Learn more: https://github.com/hydraide/hydraide
// âœ‰ Contact: peter.gebri@hydraide.com
//
// =============================================================================

syntax="proto3";

import "google/protobuf/timestamp.proto";

package hydrapb;
option go_package = "github.com/hydraide/hydraide/generated/go/hydrapb;hydrapb";

service HydraService {

  // Heartbeat checks if the Hydra server is alive.
  // The client sends a Ping and expects a Pong response.
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse) {}

  // Lock allows you to create a mutex-like lock based on a given key.
  // It queues all lock requests for the same key and only returns once the lock is granted.
  // This mechanism enables swamp- or treasure-level locking to coordinate access between microservices.
  //
  // âš ï¸ Note: Locking is logical only â€” it does not block the actual data access unless your logic respects the lock.
  // You must explicitly use the Lock/Unlock sequence around relevant operations.
  //
  // Required: TTL must be set (timeout in milliseconds).
  // If the lock cannot be acquired within this TTL, the call returns an error.
  // If a lock is granted, a LockID is returned, which must be passed to Unlock.
  rpc Lock(LockRequest) returns (LockResponse) {}

  // Unlock releases the previously granted lock based on the key and LockID.
  // If the LockID is invalid or does not match an existing lock, the call fails.
  //
  // It is crucial to always unlock your locks to avoid deadlocks.
  // If the TTL expires, the lock is automatically released.
  rpc Unlock(UnlockRequest) returns (UnlockResponse) {}

  // RegisterSwamp registers a new swamp pattern in the Hydra system.
  // A swamp pattern defines the namespace (Sanctuary/Realm/Swamp) and behavior of a storage unit.
  //
  // You can configure:
  // - Whether the swamp lives in memory or on disk
  // - How long it should stay alive without access (CloseAfterIdle)
  // - How frequently it should flush to disk (WriteInterval)
  // - Maximum file size per chunk (MaxFileSize)
  //
  // Use this to define behavior per collection before inserting data.
  rpc RegisterSwamp(RegisterSwampRequest) returns (RegisterSwampResponse) {}

  // DeRegisterSwamp removes a previously registered swamp pattern.
  // This does not delete the swamp data â€” it only removes its active configuration.
  //
  // Use this to clean up unused swamp definitions.
  rpc DeRegisterSwamp(DeRegisterSwampRequest) returns (DeRegisterSwampResponse) {}

  // Set inserts or updates one or more key-value pairs into one or more swamps.
  // You can control the behavior using two flags:
  // - CreateIfNotExist: If false, the swamp/key must already exist (update only).
  // - Overwrite: If false, the existing value will not be overwritten.
  //
  // âš ï¸ Each KeyValuePair supports multiple data types:
  // - All numeric primitives: int8, int16, int32, int64, uint8, uint16, uint32, uint64
  // - Floating point types: float32, float64
  // - Booleans, strings, bytes, and even slices (e.g., uint32[])
  //
  // ðŸ’¡ Hydra stores the value using its **actual underlying type** without upcasting,
  // which means no wasted memory or disk space â€“ you only store what you really need.
  //
  // You can also set metadata like CreatedAt, UpdatedBy, ExpiredAt, etc.
  //
  // âœ… Supports multiple swamps in a single request for batch operations.
  //
  // ðŸ”” Realtime: Any inserted or updated treasures will trigger an immediate
  // event to all active subscribers via the SubscribeToEvents stream.
  //
  // This makes Hydra suitable for:
  // - Real-time dashboards
  // - Cache invalidation listeners
  // - Live analytics feeds
  rpc Set(SetRequest) returns (SetResponse) {}

  // Get retrieves one or more key-value pairs by key from one or more swamps.
  // You must specify the swamp name and the list of keys per swamp.
  //
  // Each response includes the key, value, and metadata fields (timestamps, creators).
  // This is a type-safe, structured read â€“ no JSON parsing needed on the client side.
  rpc Get(GetRequest) returns (GetResponse) {}

  // GetAll retrieves **all** key-value pairs from a given swamp.
  //
  // This is useful for debug purposes, cache rebuilding, or initial snapshot creation.
  // Not recommended for large datasets unless scoped and filtered client-side.
  rpc GetAll(GetAllRequest) returns (GetAllResponse) {}

  // GetByIndex allows indexed reads based on fields like:
  // - ExpirationTime
  // - CreationTime
  // - Value types (e.g., VALUE_STRING, VALUE_INT32, etc.)
  //
  // You can specify the index type, sorting order (ASC/DESC), and a range using From/Limit.
  // This makes the Hydra engine powerful for search, feed, and queue-like structures.
  //
  // âš ï¸ Hydra creates index structures on-demand in memory when this method is called.
  // These indexes are **not persisted**, and are **discarded when the swamp is closed** due to inactivity.
  // This means indexing is stateless, fast, and leaves no storage overhead.
  //
  // You do not need to pre-define indexes. Simply call this method with the right IndexType.
  rpc GetByIndex(GetByIndexRequest) returns (GetByIndexResponse) {}

  // ShiftExpiredTreasures retrieves and deletes expired treasures from a given swamp.
  //
  // This method is ideal for implementing task queues, time-based processing systems,
  // or scheduled cleanup mechanisms where only expired items should be processed.
  //
  // You can control how many items to retrieve at once using the `HowMany` parameter:
  // - If `HowMany` is 0, all expired treasures will be returned (use with caution on large swamps)
  // - If `HowMany` > 0, only that many expired entries will be returned in the response
  //
  // âš ï¸ Important: This method is destructive â€“ the returned items will be permanently removed from the swamp.
  //
  // ðŸ”” Realtime: All subscribers to the swamp will receive an immediate
  // notification about the deleted treasures via the SubscribeToEvents stream.
  //
  // Use this for building things like:
  // - Delayed jobs
  // - Expiring caches
  // - Scheduled triggers (e.g. publish-after-expiry)
  rpc ShiftExpiredTreasures(ShiftExpiredTreasuresRequest) returns (ShiftExpiredTreasuresResponse) {}

  // Destroy permanently deletes the entire swamp and all its treasures.
  //
  // This removes all data associated with the given swamp, including metadata, indexes, and chunks.
  //
  // âš ï¸ Warning: This operation is irreversible. All data will be lost.
  // Use only when you're absolutely sure the swamp is no longer needed.
  //
  // Typical use cases:
  // - Cleanup after tests or temporary data
  // - User data deletion requests
  // - Full environment reset
  rpc Destroy(DestroyRequest) returns (DestroyResponse) {}

  // Delete removes one or more treasures (key-value pairs) from the specified swamp.
  //
  // This is a precise, non-destructive swamp-level operation.
  // You must provide the swamp name and the list of keys to delete.
  //
  // âœ… Supports batch deletion across multiple swamps in a single request.
  // Each swamp and its deleted keys will be included in the response.
  //
  // ðŸ”” Realtime: All subscribers to the swamp will receive an immediate
  // notification about the deleted treasures via the SubscribeToEvents stream.
  //
  // Use this to:
  // - Manually remove outdated or invalid entries
  // - Implement "soft delete" logic (client-side)
  // - Perform targeted cleanup operations
  rpc Delete(DeleteRequest) returns (DeleteResponse) {}

  // Count returns the number of treasures in one or more specified swamps.
  //
  // You provide a list of swamp names, and for each swamp Hydra returns:
  // - Whether the swamp exists
  // - How many elements (treasures) are currently stored in it
  //
  // âœ… This is useful for:
  // - Dashboard metrics and monitoring
  // - Queue size estimation
  // - Expiry-aware cleanup or batch logic
  //
  // ðŸ’¡ The count is calculated instantly from the swampâ€™s current state,
  // with no need for full traversal or manual iteration.
  //
  // Can be used across multiple swamps in a single request.
  rpc Count(CountRequest) returns (CountResponse) {}

  // IsSwampExist checks if the specified swamp exists in the given sanctuary.
  //
  // This method does not create or modify anything â€“ it only verifies existence.
  // Use it to validate swamp names before writing, migrating, or deleting.
  //
  // Typical use cases:
  // - Pre-checks before Set/Delete operations
  // - UI/UX logic (e.g. show/hide a swamp)
  // - Schema validation before batch processing
  //
  // ðŸ’¡ Note: Swamp existence does not guarantee any treasures inside â€“ it's purely structural.
  rpc IsSwampExist(IsSwampExistRequest) returns (IsSwampExistResponse) {}

  // IsKeyExist checks whether a specific key exists in a given swamp.
  //
  // This allows you to verify the presence of a treasure without retrieving its content.
  //
  // Use cases include:
  // - Validation before conditional logic (e.g. overwrite if exists)
  // - Data consistency checks
  // - TTL-aware logic (e.g. only update if key is still present)
  //
  // ðŸ’¡ Note: The value is not returned â€“ only a boolean indicator of existence.
  rpc IsKeyExist(IsKeyExistRequest) returns (IsKeyExistResponse) {}

  // SubscribeToEvents allows clients to subscribe to **all data changes** within a given swamp.
  //
  // When any treasure in the swamp is created, updated, or deleted,
  // the subscriber immediately receives an event via the gRPC stream.
  //
  // Each event includes:
  // - The new Treasure (after Set, Shift, etc.)
  // - The previous Treasure (if updated)
  // - The deleted Treasure (if removed)
  // - The EventType: NEW, UPDATED, DELETED, etc.
  // - The timestamp of the change
  //
  // ðŸ” Events are streamed continuously and in real time, making this ideal for:
  // - Realtime dashboards
  // - Reactive frontends (e.g. auto-refreshing tables)
  // - Notification systems
  // - Chat or messaging systems (event-driven communication)
  // - Distributed coordination (e.g. data sync across services)
  // - Microservice communication via event stream
  //
  // ðŸ’¡ You can use this to completely replace traditional polling or cron-based checks.
  rpc SubscribeToEvents(SubscribeToEventsRequest) returns (stream SubscribeToEventsResponse) {}

  // SubscribeToInfo allows clients to subscribe to the **size** of a given swamp.
  //
  // Whenever the number of treasures changes in the swamp (insert, delete, expire),
  // the client receives a realtime update of the current element count.
  //
  // This is useful for:
  // - Showing live counters or progress bars
  // - Monitoring queue sizes
  // - Displaying health metrics or swamp saturation
  //
  // âš¡ Events are sent immediately upon any change to the number of elements.
  rpc SubscribeToInfo(SubscribeToInfoRequest) returns (stream SubscribeToInfoResponse) {}

  // Uint32SlicePush adds one or more uint32 values to one or more uint32 slices stored in a swamp.
  //
  // ðŸ’¡ Hydra automatically ensures that each value is unique within the slice.
  // If a number already exists, it will be ignored â€“ no duplicates are ever stored.
  //
  // You can safely push multiple values at once, even if some already exist.
  // The resulting slice will contain only distinct uint32 values.
  //
  // ðŸ”” Any change to the slice triggers a real-time event to all swamp subscribers.
  // The full updated slice is included in the event payload.
  //
  // This feature is ideal for building:
  // - Reverse indexes (e.g. word â†’ [domainHash1, domainHash2])
  // - Subscriptions, permissions, ID-based tagging
  // - Memory-efficient, append-only ID lists
  //
  // âš ï¸ Recommended for cases where the slice size is small to moderate,
  // as the full slice is returned on each update.
  rpc Uint32SlicePush(AddToUint32SlicePushRequest) returns (AddToUint32SlicePushResponse) {}

  // Uint32SliceDelete removes one or more uint32 values from one or more slices.
  //
  // If a value does not exist, it is silently ignored (no error thrown).
  // The key itself (treasure) is preserved â€“ only the values inside the slice are modified.
  //
  // ðŸ”” The deletion also triggers a real-time event to all subscribers.
  rpc Uint32SliceDelete(Uint32SliceDeleteRequest) returns (Uint32SliceDeleteResponse) {}

  // Uint32SliceSize returns the number of values stored in the uint32 slice.
  //
  // Use this to:
  // - Show visual counters
  // - Estimate memory usage
  // - Monitor collection density
  rpc Uint32SliceSize(Uint32SliceSizeRequest) returns (Uint32SliceSizeResponse) {}

  // Uint32SliceIsValueExist checks whether a specific value exists inside the slice.
  //
  // This is useful when you want to validate membership before taking actions,
  // such as displaying UI states or preventing duplicate logic.
  rpc Uint32SliceIsValueExist(Uint32SliceIsValueExistRequest) returns (Uint32SliceIsValueExistResponse) {}

  // IncrementInt8 increments (or decrements) the value of the key by the specified amount,
  // if a given condition is satisfied.
  //
  // ðŸ’¡ The increment can be negative â€“ enabling both increment and decrement operations.
  // If the condition fails, the value is not modified.
  //
  // The response includes:
  // - The new (or original) value
  // - Whether the increment was applied
  //
  // ðŸ”” Realtime: Any change triggers an immediate event to all swamp subscribers via SubscribeToEvents.
  //
  // Typical use cases:
  // - Counter logic (votes, likes, attempts)
  // - Conditional stock adjustments
  // - Quota or retry limits
  rpc IncrementInt8(IncrementInt8Request) returns (IncrementInt8Response) {}

  // IncrementInt8 same logic as IncrementInt8 but for int16 values
  rpc IncrementInt16(IncrementInt16Request) returns (IncrementInt16Response) {}
  // IncrementInt32 same logic as IncrementInt8 but for int32 values
  rpc IncrementInt32(IncrementInt32Request) returns (IncrementInt32Response) {}
  // IncrementInt64 same logic as IncrementInt8 but for int64 values
  rpc IncrementInt64(IncrementInt64Request) returns (IncrementInt64Response) {}
  // IncrementUint8 same logic as IncrementInt8 but for uint8 values
  rpc IncrementUint8(IncrementUint8Request) returns (IncrementUint8Response) {}
  // IncrementUint16 same logic as IncrementInt8 but for uint16 values
  rpc IncrementUint16(IncrementUint16Request) returns (IncrementUint16Response) {}
  // IncrementUint32 same logic as IncrementInt8 but for uint32 values
  rpc IncrementUint32(IncrementUint32Request) returns (IncrementUint32Response) {}
  // IncrementUint64 same logic as IncrementInt8 but for uint64 values
  rpc IncrementUint64(IncrementUint64Request) returns (IncrementUint64Response) {}
  // IncrementFloat32 same logic as IncrementInt8 but for float32 values
  rpc IncrementFloat32(IncrementFloat32Request) returns (IncrementFloat32Response) {}
  // IncrementFloat64 same logic as IncrementInt8 but for float64 values
  rpc IncrementFloat64(IncrementFloat64Request) returns (IncrementFloat64Response) {}

}

message HeartbeatRequest {
  // Ping is an arbitrary string sent by the client.
  // Usually used to test round-trip latency or connection health.
  string Ping = 1;
}

message HeartbeatResponse {
  // Pong is the response from the Hydra server.
  // Often just echoes back a predefined value ("pong") for health check verification.
  string Pong = 1;
}

message LockRequest {
  // Key is the unique identifier for the lock.
  // Any client that wants to lock the same resource must use the same key.
  // This could represent a swamp name, a composite key, or a logical domain (e.g. "catalog-write-lock").
  string Key = 1;

  // TTL is the time-to-live for the lock in milliseconds.
  // If the lock is not released within this period, it is automatically freed to avoid deadlocks.
  int64 TTL = 2;
}

message LockResponse {
  // LockID is the unique token representing the granted lock instance.
  // This must be used in the corresponding Unlock request to release the lock.
  string LockID = 1;
}


message UnlockRequest {
  // Key is the same identifier used during locking.
  string Key = 1;

  // LockID is the token returned by the Lock call.
  // Must match exactly in order to release the lock.
  string LockID = 2;
}

message UnlockResponse {
  // Empty response â€“ success is indicated by the lack of an error.
}

message DestroyRequest {
  // SwampName is the name of the swamp to be permanently deleted.
  //
  // This removes all treasures and metadata associated with the swamp.
  // Use with caution â€“ this operation is irreversible.
  string SwampName = 1;
}


message DestroyResponse {
  // Empty response. If no error is returned, the operation was successful.
  // If the swamp is protected by Automover, an error will be returned instead.
}

message SubscribeToInfoRequest {
  // SwampName is the name of the swamp to observe.
  //
  // The server will monitor this swamp and send realtime updates
  // whenever the number of treasures in it changes.
  string SwampName = 2;
}

message SubscribeToInfoResponse {
  // SwampName is the name of the swamp the count refers to.
  string SwampName = 1;

  // AllElements is the current number of treasures in the swamp.
  //
  // This count is updated in real time as treasures are added, deleted, or expired.
  uint64 AllElements = 2;
}

message SubscribeToEventsRequest {
  // SwampName is the name of the swamp to subscribe to.
  //
  // All changes (insert, update, delete) in this swamp will be streamed in real time.
  string SwampName = 2;
}

message SubscribeToEventsResponse {
  // SwampName is the swamp where the event occurred.
  string SwampName = 1;

  // Treasure is the current value after the change (for NEW and UPDATED events).
  Treasure Treasure = 2;

  // OldTreasure is the previous value before the update (only for UPDATED events).
  // It will be empty for NEW or DELETE events.
  Treasure OldTreasure = 3;

  // DeletedTreasure is the removed value (only for DELETED events).
  // It will be empty for NEW and UPDATED events.
  Treasure DeletedTreasure = 4;

  // EventTime is the timestamp when the change happened (server-generated).
  google.protobuf.Timestamp EventTime = 5;

  // Status is the type of the event: NEW, UPDATED, DELETED, etc.
  Status.Code Status = 6;
}


message SwampKeys {
  // SwampName is the name of the swamp to operate on.
  //
  // All keys in this request belong to this one swamp.
  string SwampName = 1;

  // Keys is the list of treasure keys we want to fetch, delete, or inspect.
  //
  // Used for batch operations like:
  // - Get multiple values
  // - Delete selected treasures
  // - Check key existence
  repeated string Keys = 2;
}


message RegisterSwampRequest {
  // SwampPattern defines the full namespace of the swamp using the Sanctuary/Realm/Swamp pattern.
  //
  // Example: "search/hu/products"
  string SwampPattern = 1;

  // CloseAfterIdle defines how long (in seconds) the swamp stays open after its last access.
  //
  // Once this timeout expires with no reads or writes, the swamp will be closed and flushed to disk.
  // This helps optimize memory usage for less-frequently accessed data.
  int64 CloseAfterIdle = 2;

  // IsInMemorySwamp determines whether the swamp should only exist in memory.
  //
  // If true: all data is kept in RAM (fast but volatile).
  // If false: data is persisted to disk (slower, but durable).
  bool IsInMemorySwamp = 3;

  // WriteInterval defines how often data should be flushed to disk, in seconds.
  //
  // Optional. Only applies when IsInMemorySwamp is false.
  // Lower values ensure better durability, higher values reduce I/O.
  optional int64 WriteInterval = 4;

  // MaxFileSize sets the maximum size (in bytes) for a single compressed file chunk.
  //
  // Optional. Applies only when IsInMemorySwamp is false.
  // Useful for optimizing SSD usage and controlling compaction behavior.
  optional int64 MaxFileSize = 5;
}

message RegisterSwampResponse {
  // Empty response. Success is indicated by the absence of error.
}

message DeRegisterSwampRequest {
  // SwampPattern is the full namespace pattern of the swamp to remove from the active registry.
  //
  // âš ï¸ Note: This does NOT delete the swamp or its data.
  // It only removes its configuration from the registry.
  string SwampPattern = 1;
}

message DeRegisterSwampResponse {
  // Empty response. Success is indicated by the absence of error.
}


message SetRequest {
  // Swamps is a list of write instructions, each targeting a specific swamp.
  //
  // You can insert or update multiple key-value pairs across multiple swamps in a single request.
  repeated SwampRequest Swamps = 1;
}

message SwampRequest {
  // SwampName is the name of the target swamp where the data should be written.
  string SwampName = 1;

  // KeyValues is the list of key-value pairs to insert or update in this swamp.
  repeated KeyValuePair KeyValues = 2;

  // CreateIfNotExist determines whether Hydra should create the swamp and/or key if they don't exist yet.
  //
  // - true â†’ create missing swamp and keys if needed (upsert)
  // - false â†’ only allow updates to existing values
  bool CreateIfNotExist = 3;

  // Overwrite controls whether existing values should be replaced.
  //
  // - true â†’ existing values will be overwritten
  // - false â†’ existing values will remain untouched
  //
  // Combine this with CreateIfNotExist for fine-grained behavior:
  // - true + true = upsert
  // - false + true = update only
  // - true + false = insert only
  // - false + false = no-op (used for dry run / test)
  bool Overwrite = 4;
}


message KeyValuePair {
  // Key is the unique identifier of the treasure within the swamp.
  string Key = 1;

  // One of the following typed fields can be used to set the value.
  // Only the non-zero / non-nil field will be used:

  optional int32  Int8Val = 2;
  optional int32  Int16Val = 3;
  optional int32  Int32Val = 4;
  optional int64  Int64Val = 5;

  optional uint32  Uint8Val = 6;
  optional uint32  Uint16Val = 7;
  optional uint32  Uint32Val = 8;
  optional uint64  Uint64Val = 9;

  optional float   Float32Val = 10;
  optional double  Float64Val = 11;

  optional string StringVal = 12;

  optional Boolean.Type BoolVal = 13;
  optional bytes BytesVal = 14;

  // Uint32Slice is a special set-like slice of uint32 values.
  //
  // It is deduplicated automatically by Hydra: each number can only exist once.
  // Used for reverse indexes, relations, and ID mapping.
  repeated uint32 Uint32Slice = 15;

  // VoidVal can be used to explicitly clear the value, without removing the key.
  //
  // If true:
  // - The treasure will be retained, but its content will be set to an empty/null value.
  // - Useful for clearing sensitive data or resetting state while keeping the key.
  //
  // ðŸ’¡ Advanced use: You can use VoidVal to store keys without any associated value.
  // This is ideal for building key-only swamps (e.g. keyword sets, user tags, reverse indexes).
  // Such entries take **zero storage space** beyond the key itself.
  //
  // ðŸ§  Bonus: If you don't set CreatedAt / UpdatedAt / Metadata, Hydra won't generate them either.
  // This keeps your swamp minimal and ultra-efficient when you don't need full metadata.
  optional bool VoidVal = 16;

  // Metadata â€“ these fields can be optionally set to override the system-generated timestamps.
  // Useful for syncing external sources or customizing indexing behavior.
  optional google.protobuf.Timestamp CreatedAt = 17;
  optional string CreatedBy = 18;
  optional google.protobuf.Timestamp UpdatedAt = 19;
  optional string UpdatedBy = 20;

  // ExpiredAt sets the expiration time for the treasure.
  //
  // If this field is set, Hydra will treat the treasure as **expired** after the given timestamp.
  // Expired treasures remain accessible until explicitly queried or removed.
  //
  // ðŸ”¥ Powerful features unlocked with ExpiredAt:
  // - You can use `GetByIndex` with `EXPIRATION_TIME` to retrieve only expired (or not yet expired) entries.
  // - You can call `ShiftExpiredTreasures` to **extract and delete** expired items in a single atomic operation.
  // - Swamps can be organized like queues, schedules, or TTL-based caches using this field.
  //
  // ðŸ’¡ If ExpiredAt is not set, the treasure will **never expire** automatically.
  optional google.protobuf.Timestamp ExpiredAt = 21;

}


message SetResponse {
  // Swamps is a list of responses, one per swamp.
  repeated SwampResponse Swamps = 1;
}
message SwampResponse {
  // SwampName is the name of the swamp this response refers to.
  string SwampName = 1;

  // KeysAndStatuses contains the outcome of each keyâ€™s operation.
  repeated KeyStatusPair KeysAndStatuses = 2;

  // ErrorCode is set if the entire swamp operation failed.
  // (e.g., swamp doesn't exist and CreateIfNotExist was false)
  optional ErrCodeEnum ErrorCode = 3;

  enum ErrCodeEnum {
    CanNotBeExecuted = 0;
    SwampDoesNotExist = 1;
  }
}

message KeyStatusPair {
  // Key is the identifier of the treasure.
  string Key = 1;

  // Status indicates what happened to the key during the Set operation.
  Status.Code Status = 2;
}
message Status {
  enum Code {
    NOT_FOUND = 0;        // The key does not exist and no changes were made
    NEW = 1;              // The key was newly created
    UPDATED = 2;          // The key existed and was updated
    DELETED = 3;          // The key was deleted
    NOTHING_CHANGED = 4;  // Operation was skipped due to Overwrite=false or same value
  }
}


message GetRequest {
  // Swamps is a list of swamps with their associated keys to retrieve.
  //
  // You can batch multiple swamp/key combinations into a single request,
  // making the operation efficient for distributed or sharded datasets.
  //
  // Example:
  // - Swamp "hu/products" â†’ get keys ["123", "456"]
  // - Swamp "de/users" â†’ get keys ["alice", "bob"]
  repeated GetSwamp Swamps = 1;
}


message GetSwamp {
  // SwampName is the name of the swamp to read from.
  string SwampName = 1;

  // Keys is the list of treasure keys to retrieve from this swamp.
  repeated string Keys = 3;
}

message GetResponse {
  // Swamps contains the result of each swamp that was queried.
  repeated GetSwampResponse Swamps = 1;
}

message GetSwampResponse {
  // SwampName is the swamp from which the treasures were returned.
  string SwampName = 1;

  // IsExist tells whether the swamp actually exists.
  //
  // If false, no data will be returned for this swamp.
  bool IsExist = 2;

  // Treasures contains the values of all successfully retrieved keys.
  // If a key did not exist, it will be omitted from the list.
  repeated Treasure Treasures = 3;
}


message GetAllRequest {
  // SwampName is the name of the swamp you want to retrieve all treasures from.
  //
  // Hydra will return every key-value pair stored in this swamp, regardless of expiration or status.
  //
  // âš ï¸ Caution: For large swamps, this can return a lot of data.
  // Consider using pagination or GetByIndex instead for better control.
  string SwampName = 1;
}


message GetAllResponse {
  // Treasures contains all key-value pairs from the requested swamp.
  //
  // Each Treasure includes its key, type-specific value, metadata (if any),
  // and its current existence status.
  //
  // ðŸ’¡ Useful for:
  // - Initial snapshot generation
  // - Manual data inspection
  // - Rebuilding in-memory views or local caches
  repeated Treasure Treasures = 1;
}


message ShiftExpiredTreasuresRequest {
  // SwampName is the name of the swamp you want to shift expired treasures from.
  string SwampName = 1;

  // HowMany defines how many expired treasures should be returned and deleted.
  //
  // - If set to 0 â†’ Hydra will return **all** expired entries from the swamp.
  // - If greater than 0 â†’ only the specified number of expired treasures will be returned.
  //
  // âš ï¸ Note: This operation is destructive â€“ the shifted treasures will be removed immediately.
  int32 HowMany = 2;
}


message ShiftExpiredTreasuresResponse {
  // Treasures contains the expired entries that were retrieved and deleted from the swamp.
  //
  // Each treasure includes its key, value, and metadata at the time of expiration.
  //
  // ðŸ”” Realtime: These deletions will also trigger `SubscribeToEvents` notifications.
  repeated Treasure Treasures = 1;
}


message Treasure {
  // Key is the unique identifier of the treasure within the swamp.
  string Key = 1;

  // IsExist indicates whether the treasure was actually found in the swamp.
  //
  // If false:
  // - The treasure was requested, but does not exist.
  // - All value and metadata fields will be unset.
  bool IsExist = 2;

  // --- Value fields: one (or none) will be set based on the stored type ---

  optional int32  Int8Val = 3;
  optional int32  Int16Val = 4;
  optional int32  Int32Val = 5;
  optional int64  Int64Val = 6;

  optional uint32 Uint8Val = 7;
  optional uint32 Uint16Val = 8;
  optional uint32 Uint32Val = 9;
  optional uint64 Uint64Val = 10;

  optional float   Float32Val = 11;
  optional double  Float64Val = 12;

  optional string  StringVal = 13;

  optional Boolean.Type BoolVal = 14;

  optional bytes   BytesVal = 15;

  // Uint32Slice is a special, automatically deduplicated list of uint32 values.
  //
  // Ideal for storing IDs, reverse indexes, or permission sets.
  repeated uint32 Uint32Slice = 16;

  // --- Metadata ---

  // CreatedAt is the timestamp when the treasure was first created.
  //
  // âš ï¸ Hydra does not generate this automatically.
  // This field will only be present if you explicitly set it during the Set operation.
  optional google.protobuf.Timestamp CreatedAt = 17;

  // CreatedBy stores the identifier (user/system) that created the treasure.
  //
  // âš ï¸ Optional. Only stored if provided at write time.
  optional string CreatedBy = 18;

  // UpdatedAt is the last modification timestamp of the treasure.
  //
  // âš ï¸ Optional. Hydra won't auto-populate this â€” you must set it manually if needed.
  optional google.protobuf.Timestamp UpdatedAt = 19;

  // UpdatedBy stores the identifier of who last modified the treasure.
  //
  // âš ï¸ Optional. Set it explicitly in the Set request if tracking is desired.
  optional string UpdatedBy = 20;

  // ExpiredAt defines the expiration time for the treasure.
  //
  // After this time, the treasure is considered expired and can be retrieved or removed using:
  // - `GetByIndex` with `EXPIRATION_TIME`
  // - `ShiftExpiredTreasures`
  //
  // âš ï¸ Important: Hydra does NOT auto-generate this value.
  // If you want a treasure to expire, you must set ExpiredAt yourself during the `Set` operation.
  //
  // If ExpiredAt is not set:
  // - The treasure is considered to never expire
  // - It will not appear in expiration-based queries
  optional google.protobuf.Timestamp ExpiredAt = 21;

}


message Boolean {
  enum Type {
    TRUE = 0;
    FALSE = 1;
  }
}

message GetByIndexRequest {
  // SwampName is the name of the swamp to query.
  //
  // The index will be built in memory for this swamp at query time.
  string SwampName = 1;

  // IndexType specifies which field to index and query on.
  //
  // Supported indexes:
  // - KEY â†’ Sort alphabetically by key
  // - EXPIRATION_TIME â†’ Query based on ExpiredAt timestamps
  // - CREATION_TIME â†’ Query based on CreatedAt timestamps
  // - UPDATE_TIME â†’ Query based on UpdatedAt timestamps
  // - VALUE_* â†’ Query by the actual value (e.g., int, string, float)
  IndexType.Type IndexType = 2;

  // OrderType defines the sort direction:
  // - ASC â†’ Oldest/smallest first
  // - DESC â†’ Newest/largest first
  OrderType.Type OrderType = 3;

  // From defines the starting index (zero-based).
  //
  // Use it for pagination or skipping elements.
  // Set to 0 to start from the beginning.
  int32 From = 4;

  // Limit defines how many items to return.
  //
  // Set to 0 to return all results (âš ï¸ caution on large datasets).
  int32 Limit = 5;
}

message IndexType {
  enum Type {
    // Key index (alphabetical)
    KEY = 0;

    // Metadata-based indexes
    EXPIRATION_TIME = 1;
    CREATION_TIME = 2;
    UPDATE_TIME = 3;

    // Value-based indexes
    VALUE_INT8 = 4;
    VALUE_INT16 = 5;
    VALUE_INT32 = 6;
    VALUE_INT64 = 7;

    VALUE_UINT8 = 8;
    VALUE_UINT16 = 9;
    VALUE_UINT32 = 10;
    VALUE_UINT64 = 11;

    VALUE_FLOAT32 = 12;
    VALUE_FLOAT64 = 13;

    VALUE_STRING = 14;
  }
}

message OrderType {
  enum Type {
    ASC = 0;  // ascending
    DESC = 1; // descending
  }
}
message GetByIndexResponse {
  // Treasures contains the list of key-value pairs sorted and filtered
  // according to the request's index and parameters.
  repeated Treasure Treasures = 1;
}


message DeleteRequest {
  // Swamps contains one or more swamp/key combinations for deletion.
  //
  // You can batch-delete multiple keys from multiple swamps in a single request.
  repeated SwampKeys Swamps = 1;

  message SwampKeys {
    // SwampName identifies the target swamp.
    string SwampName = 1;

    // Keys are the specific treasure keys to delete from the swamp.
    repeated string Keys = 2;
  }
}


message DeleteResponse {
  // Responses holds the result of the delete operations, swamp by swamp.
  repeated SwampDeleteResponse Responses = 1;

  message SwampDeleteResponse {
    // SwampName is the swamp where deletion was attempted.
    string SwampName = 1;

    // ErrorCode indicates if the swamp existed or failed to be accessed.
    optional ErrorCodeEnum ErrorCode = 2;

    // KeyStatuses contains the result of each key deletion:
    // NEW (not found before), DELETED, NOTHING_CHANGED, etc.
    repeated KeyStatusPair KeyStatuses = 3;

    enum ErrorCodeEnum {
      SwampDoesNotExist = 0;
    }
  }
}


message CountRequest {
  // SwampNames is the list of swamps you want to inspect.
  //
  // You can count multiple swamps at once.
  repeated string SwampNames = 1;
}

message CountResponse {
  // Swamps contains the count result for each swamp queried.
  repeated CountSwamp Swamps = 1;
}

message CountSwamp {
  // SwampName is the name of the swamp counted.
  string SwampName = 1;

  // IsExist tells whether the swamp exists in the system.
  bool IsExist = 2;

  // Count is the number of treasures currently stored in this swamp.
  int32 Count = 3;
}


message IncrementInt8Request {
  // SwampName is the name of the swamp where the value resides.
  string SwampName = 1;

  // Key is the identifier of the treasure to increment.
  string Key = 2;

  // IncrementBy is the signed integer to add (or subtract) from the current value.
  //
  // âš ï¸ Although this is declared as int32, only int8-range values are stored.
  // Hydra internally converts and enforces the correct range.
  //
  // ðŸ’¡ Supports negative values for decrementing.
  int32 IncrementBy = 3;

  // Condition determines whether the increment should proceed.
  IncrementInt8Condition Condition = 4;
}


message IncrementInt8Condition {
  // The relational operator to apply (e.g., GREATER_THAN, EQUAL).
  Relational.Operator RelationalOperator = 1;

  // The value to compare against.
  //
  // âš ï¸ Despite being int32 here (due to proto3 limitation), only valid int8 values are considered.
  int32 Value = 2;
}


message IncrementInt8Response {
  // Value is the resulting value after the increment (or original if unchanged).
  //
  // Note: âš ï¸ This is represented as int32 due to proto3 constraints,
  // but internally Hydra uses int8 precision and guarantees type-safety.
  int32 Value = 1;

  // IsIncremented indicates whether the increment was actually applied.
  bool IsIncremented = 2;
}

message IncrementInt16Request {
  // SwampName is the name of the swamp where the value resides.
  string SwampName = 1;

  // Key is the identifier of the treasure to increment.
  string Key = 2;

  // IncrementBy is the signed integer to add (or subtract) from the current value.
  //
  // âš ï¸ Although this is declared as int32, Hydra stores the value as int16.
  // The system enforces proper bounds and type conversion internally.
  int32 IncrementBy = 3;

  // Condition determines whether the increment should proceed.
  IncrementInt16Condition Condition = 4;
}

message IncrementInt16Condition {
  // The relational operator to apply (e.g., GREATER_THAN, LESS_THAN).
  Relational.Operator RelationalOperator = 1;

  // The value to compare against.
  //
  // âš ï¸ While represented as int32 (due to proto3 constraints),
  // Hydra treats it as an int16 behind the scenes.
  int32 Value = 2;
}

message IncrementInt16Response {
  // Value is the resulting value after incrementing.
  //
  // Note: Represented as int32 for compatibility, but Hydra ensures
  // that the underlying type remains int16 and no data loss occurs.
  int32 Value = 1;

  // IsIncremented tells whether the value was actually modified.
  bool IsIncremented = 2;
}

message IncrementInt32Request {
  // SwampName is the name of the swamp where the value resides.
  string SwampName = 1;

  // Key is the treasure key whose value we want to increment.
  string Key = 2;

  // IncrementBy is the signed 32-bit integer to add or subtract.
  int32 IncrementBy = 3;

  // Condition must be satisfied for the increment to apply.
  IncrementInt32Condition Condition = 4;
}

message IncrementInt32Condition {
  // The relational operator for evaluating the current value.
  Relational.Operator RelationalOperator = 1;

  // Value to compare against (int32).
  int32 Value = 2;
}

message IncrementInt32Response {
  // Value is the resulting int32 value after increment.
  int32 Value = 1;

  // IsIncremented is true if the value was changed.
  bool IsIncremented = 2;
}

message IncrementInt64Request {
  // SwampName is the name of the swamp where the treasure is stored.
  string SwampName = 1;

  // Key identifies the treasure you want to increment.
  string Key = 2;

  // IncrementBy is the signed 64-bit integer to add (can be negative).
  //
  // ðŸ’¡ Ideal for working with timestamps, counters, large numeric values.
  int64 IncrementBy = 3;

  // Condition must be met for the increment to happen.
  IncrementInt64Condition Condition = 4;
}


message IncrementInt64Condition {
  // Relational operator used for conditional increment.
  Relational.Operator RelationalOperator = 1;

  // The reference value to compare the current value against.
  int64 Value = 2;
}

message IncrementInt64Response {
  // Value is the resulting value after the increment (or the original value if condition failed).
  int64 Value = 1;

  // IsIncremented indicates whether the operation was applied.
  bool IsIncremented = 2;
}



message IncrementUint8Request {
  // SwampName identifies the swamp where the treasure lives.
  string SwampName = 1;

  // Key is the treasure to increment.
  string Key = 2;

  // IncrementBy is the unsigned integer to add to the current value.
  //
  // âš ï¸ Although represented as uint32 due to proto3 limitations,
  // Hydra stores this as a true uint8 internally (0â€“255).
  //
  // Any overflow is safely rejected and not applied.
  uint32 IncrementBy = 3;

  // Condition to be evaluated before applying the increment.
  IncrementUint8Condition Condition = 4;
}

message IncrementUint8Condition {
  // The relational operator (e.g. EQUAL, GREATER_THAN, etc.)
  Relational.Operator RelationalOperator = 1;

  // Value to compare against before incrementing.
  //
  // âš ï¸ Same as above: Only values within the uint8 range are accepted internally.
  uint32 Value = 2;
}

message IncrementUint8Response {
  // Value is the resulting value after increment.
  //
  // âš ï¸ Represented as uint32 in the response, but internally it's stored as uint8.
  uint32 Value = 1;

  // IsIncremented is true if the increment was applied.
  bool IsIncremented = 2;
}


message IncrementUint16Request {
  // SwampName is the name of the swamp where the treasure is stored.
  string SwampName = 1;

  // Key identifies the target treasure.
  string Key = 2;

  // IncrementBy is the unsigned integer to add (or subtract, if allowed).
  //
  // âš ï¸ Represented as `uint32` in the gRPC interface, but Hydra stores it as true `uint16` internally.
  // Allowed value range: 0 to 65,535
  uint32 IncrementBy = 3;

  // Condition to be satisfied before increment is applied.
  IncrementUint16Condition Condition = 4;
}


message IncrementUint16Condition {
  // The logical operator used for evaluating the current value.
  Relational.Operator RelationalOperator = 1;

  // Comparison reference value.
  //
  // âš ï¸ Although this is a `uint32`, Hydra handles it as `uint16` internally.
  uint32 Value = 2;
}

message IncrementUint16Response {
  // Value is the final (or original) value after attempted increment.
  //
  // Still represented as `uint32` due to proto limitations, but only 0..65535 values are stored.
  uint32 Value = 1;

  // IsIncremented tells whether the value was actually modified.
  bool IsIncremented = 2;
}


message IncrementUint32Request {
  // SwampName specifies the target swamp.
  string SwampName = 1;

  // Key identifies the treasure to increment.
  string Key = 2;

  // IncrementBy is the unsigned 32-bit integer value to add.
  //
  // ðŸ’¡ Supports any uint32 value (0â€“4,294,967,295)
  uint32 IncrementBy = 3;

  // Condition must be true for the increment to be applied.
  IncrementUint32Condition Condition = 4;
}

message IncrementUint32Condition {
  // The relational operator used to evaluate the current value.
  Relational.Operator RelationalOperator = 1;

  // The value to compare against.
  uint32 Value = 2;
}

message IncrementUint32Response {
  // Value is the updated value after incrementing,
  // or the original if the condition failed.
  uint32 Value = 1;

  // IsIncremented indicates whether the value was modified.
  bool IsIncremented = 2;
}


message IncrementUint64Request {
  // SwampName is the swamp where the treasure is located.
  string SwampName = 1;

  // Key identifies the treasure whose value will be incremented.
  string Key = 2;

  // IncrementBy is the amount to add.
  //
  // ðŸ’¡ Supports the full range of unsigned 64-bit integers (0 to 18 quintillion+)
  uint64 IncrementBy = 3;

  // Condition must be satisfied for the operation to take place.
  IncrementUint64Condition Condition = 4;
}


message IncrementUint64Condition {
  // Logical operator used to compare current value.
  Relational.Operator RelationalOperator = 1;

  // The uint64 value to compare the current treasure value against.
  uint64 Value = 2;
}

message IncrementUint64Response {
  // Value is the resulting value after the operation (or the original).
  uint64 Value = 1;

  // IsIncremented is true if the operation was applied.
  bool IsIncremented = 2;
}



message Relational {
  enum Operator {
    EQUAL = 0;                  // value == reference
    GREATER_THAN = 1;           // value > reference
    GREATER_THAN_OR_EQUAL = 2;  // value >= reference
    LESS_THAN = 3;              // value < reference
    LESS_THAN_OR_EQUAL = 4;     // value <= reference
    NOT_EQUAL = 5;              // value != reference
  }
}


message IncrementFloat32Request {
  // SwampName identifies the swamp where the treasure is stored.
  string SwampName = 1;

  // Key points to the specific treasure we want to modify.
  string Key = 2;

  // IncrementBy is the amount to add (can be negative).
  //
  // ðŸ’¡ Supports 32-bit floating point numbers.
  float IncrementBy = 3;

  // Condition must be met for the change to happen.
  IncrementFloat32Condition Condition = 4;
}


message IncrementFloat32Condition {
  // Logical check to evaluate before applying the increment.
  Relational.Operator RelationalOperator = 1;

  // The float value to compare the current treasure against.
  float Value = 2;
}

message IncrementFloat32Response {
  // Value is the result after the (conditional) increment.
  float Value = 1;

  // IsIncremented is true if the change was applied.
  bool IsIncremented = 2;
}


message IncrementFloat64Request {
  // SwampName is the target swamp where the treasure lives.
  string SwampName = 1;

  // Key identifies the treasure to be incremented.
  string Key = 2;

  // IncrementBy is the floating-point value to add.
  //
  // âœ… Can be positive or negative.
  // âœ… Uses 64-bit floating-point precision.
  double IncrementBy = 3;

  // Condition that must be true for the increment to apply.
  IncrementFloat64Condition Condition = 4;
}

message IncrementFloat64Condition {
  // Comparison operator (e.g. GREATER_THAN, EQUAL, etc.)
  Relational.Operator RelationalOperator = 1;

  // Reference value to evaluate the current treasure against.
  double Value = 2;
}

message IncrementFloat64Response {
  // Value is the new (or unchanged) value after the request.
  double Value = 1;

  // IsIncremented tells if the change actually occurred.
  bool IsIncremented = 2;
}

// KeySlicePair represents a mapping between a key and a list of uint32 values.
// Used for slice-related operations like push and delete.
message KeySlicePair {
  // Key identifies the treasure containing the uint32 slice.
  string Key = 1;

  // Values are the uint32 values to add or remove.
  repeated uint32 Values = 2;
}

// AddToUint32SlicePushRequest adds one or more uint32 values to one or more keys.
message AddToUint32SlicePushRequest {
  // SwampName is the name of the swamp containing the target slices.
  string SwampName = 1;

  // KeySlicePairs contains one or more key â†’ value(s) mappings to push into the slices.
  repeated KeySlicePair KeySlicePairs = 2;
}

// AddToUint32SlicePushResponse is returned after a successful push operation.
// This message is intentionally empty.
message AddToUint32SlicePushResponse {}

// Uint32SliceDeleteRequest removes one or more values from one or more uint32 slices.
message Uint32SliceDeleteRequest {
  // SwampName is the name of the swamp where the slices are located.
  string SwampName = 1;

  // KeySlicePairs contains the keys and values to remove from the corresponding slices.
  repeated KeySlicePair KeySlicePairs = 2;
}

// Uint32SliceDeleteResponse is returned after a successful delete operation.
// This message is intentionally empty.
message Uint32SliceDeleteResponse {}

// Uint32SliceSizeRequest queries the size (number of elements) of a specific uint32 slice.
message Uint32SliceSizeRequest {
  // SwampName is the name of the swamp containing the slice.
  string SwampName = 1;

  // Key is the identifier of the treasure whose slice we want to measure.
  string Key = 2;
}

// Uint32SliceSizeResponse returns the current number of values in the requested slice.
message Uint32SliceSizeResponse {
  // Size is the total number of uint32 values in the slice.
  int64 Size = 1;
}

// Uint32SliceIsValueExistRequest checks if a specific uint32 value exists in a slice.
message Uint32SliceIsValueExistRequest {
  // SwampName is the name of the swamp containing the slice.
  string SwampName = 1;

  // Key is the treasure containing the slice.
  string Key = 2;

  // Value is the uint32 number we want to check for existence.
  uint32 Value = 3;
}

// Uint32SliceIsValueExistResponse returns whether the specified value is present in the slice.
message Uint32SliceIsValueExistResponse {
  // IsExist is true if the value is present in the slice, false otherwise.
  bool IsExist = 1;
}

// IsSwampExistRequest checks whether a specific swamp exists in the current sanctuary.
message IsSwampExistRequest {
  // SwampName is the name of the swamp to check.
  string SwampName = 1;
}

// IsSwampExistResponse returns the existence status of the swamp.
message IsSwampExistResponse {
  // IsExist will be true if the swamp exists, false otherwise.
  bool IsExist = 1;
}

// IsKeyExistRequest checks whether a specific key exists within a given swamp.
message IsKeyExistRequest {
  // SwampName is the name of the swamp where the key is expected.
  string SwampName = 1;

  // Key is the identifier of the treasure to check for existence.
  string Key = 2;
}

// IsKeyExistResponse returns the existence status of the given key in the swamp.
message IsKeyExistResponse {
  // IsExist will be true if the key is present in the swamp, false otherwise.
  bool IsExist = 1;
}
